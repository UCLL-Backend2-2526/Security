# Role Based Access Control (RBAC)

## Wat gaan we doen?

Momenteel kunnen alle geregistreerde gebruikers alles doen. In de meeste realistische applicaties
is dat niet het geval. Zo mag bijvoorbeeld een lector de cursus aanpassen, terwijl een student
dat niet mag doen. In deze stap gaan we rollen toekennen aan gebruikers: readers mogen enkel
lezen (`GET` requests) en editors mogen ook aanpassingen doen (`POST`, `PUT` en `DELETE` requests).

## Stappen

### 1. Toevoegen van een rol aan gebruikers

Eerst introduceren we een [`Role`](./src/main/java/be/ucll/backend2/model/Role.java) enum. Deze kunnen we dan
toevoegen aan de [`User`](./src/main/java/be/ucll/backend2/model/User.java)-klasse:

```java
@NotNull
@Column(nullable = false)
@Enumerated(EnumType.STRING)
private Role role;
```

Met `@Enumerated(EnumType.STRING)` zorgen we ervoor dat dit in de database wordt opgeslagen als een string (`READER` of `EDITOR`)
en niet als een getal (`0` of `1`). Dit heeft een paar voordelen:

- We zien nu in de database duidelijk over welke rol het gaat.
- Dit voorkomt problemen als we bijvoorbeeld een rol zouden tussenvoegen. Dit zou de nummering veranderen.

We kunnen ook de gepaste getters en setters toevoegen en ervoor zorgen dat elke gebruiker standaard de `READER` rol krijgt:

```java
protected User() {
    setRole(Role.READER);
}

public User(String emailAddress, String hashedPassword) {
    // this() roept de default constructor op
    this();
    setEmailAddress(emailAddress);
    setHashedPassword(hashedPassword);
}
```

We willen typisch niet dat gebruikers zelf hun rol kiezen, vandaar dat we de rol niet toevoegen als een parameter in de constructor.
Het is eerder aan bijvoorbeeld een beheerder om de rol van een gebruiker aan te passen.

Om onze database aanpassingen compleet te maken passen we `schema.sql` aan met een extra kolom voor de rol:

```sql
CREATE TABLE "user"
(
    id              BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    email_address   VARCHAR(255)                            NOT NULL,
    hashed_password VARCHAR(255)                            NOT NULL,
    role            VARCHAR(255)                            NOT NULL,
    CONSTRAINT pk_user PRIMARY KEY (id)
);
```

Om al een `EDITOR` in de database te hebben gebruiken we een `data.sql`:

```sql
INSERT INTO "user" (email_address, hashed_password, role)
VALUES ('editor@example.com', '{noop}editor', 'EDITOR');
```

### 2. Spring Security rollen laten herkennen

Nu zit onze informatie over de rollen in de database, maar Spring Security weet nog niet wat de rollen van gebruikers zijn. In stap 3 hebben we een eigen
`UserDetailsService` geïmplementeerd met bijhorende implementatie van `UserDetails`: [`UserDetailsImpl`](./src/main/java/be/ucll/backend2/model/UserDetailsImpl.java).
Hier hadden we voorlopig de `getAuthorities()`-methode nog een lege lijst laten returnen. Nu kunnen we deze methode aanpassen naar:

```java
@Override
public Collection<? extends GrantedAuthority> getAuthorities() {
    final List<String> roles = switch (user.getRole()) {
        case Role.READER -> List.of("ROLE_READER");
        case Role.EDITOR -> List.of("ROLE_READER", "ROLE_EDITOR");
    };
    return roles.stream().map(role -> new SimpleGrantedAuthority(role)).toList();
}
```

Spring Security verwacht een `Collection` (bv. een `Set` of een `List`) van `GrantedAuthority` objecten. De simpelste manier om zo'n "granted authority" aan te
maken is met een `SimpleGrantedAuthority`. Deze heeft één argument: een string. De conventie die Spring Security hanteert voor rollen is om deze string te laten
beginnen met `ROLE_`.

Omdat een `EDITOR` eigenlijk alles mag wat een `READER` mag doen, kennen we zowel de `ROLE_READER` als `ROLE_EDITOR` granted authority toe aan een `EDITOR`. Een
`READER` krijgt enkel `ROLE_READER`.

### 3. Rechten bepalen

Nu Spring Security weet wat de rechten van onze gebruikers zijn kunnen we onze [`SecurityFilterChain`](./src/main/java/be/ucll/backend2/config/SecurityConfig.java) aanpassen:

```java
.authorizeHttpRequests(
        authorizeRequests ->
                authorizeRequests
                        .requestMatchers(HttpMethod.POST, "/api/v1/users").permitAll()
                        .requestMatchers("/error").permitAll()
                        .requestMatchers(HttpMethod.GET).hasRole("READER")
                        .anyRequest().hasRole("EDITOR")
)
```

Met `hasRole` kunnen we afdwingen dat enkel gebruikers met een bepaalde rol toegang hebben tot bepaalde endpoints. Hier stellen we in dat een gebruiker met de rol `READER` alle `GET`-requests mag doen:

```java
.requestMatchers(HttpMethod.GET).hasRole("READER")
```

De `EDITOR` heeft dan ook toegang tot al de rest:

```java
.anyRequest().hasRole("EDITOR")
```

## Wat zien we nu?

Je zal merken als je nu requests uitvoert met Postman dat onze editor (username `editor@example.com`, wachtwoord `editor`) overal toegang toe heeft,
terwijl als je een reader zou aanmaken (via `POST /api/v1/users`) dat deze enkel toegang heeft tot alle `GET` endpoints.

## Conclusies

- Spring Security gebruikt "granted authorities" om te weten welke gebruikers welke rechten hebben.
- Een granted authority die begint met `ROLE_` wordt aanzien als een rol door Spring Security.
- Met `hasRole(...)` kunnen we afdwingen welke rollen toegang hebben tot welke endpoints.

## Volgende stappen

Momenteel is de toegang op basis van rollen centraal geconfigureerd in [`SecurityConfig`](./src/main/java/be/ucll/backend2/config/SecurityConfig.java). Het kan handiger of
leesbaarder zijn om dit dichter bij de endpoint zelf te doen. We gaan hiervoor zorgen in de volgende stap.
